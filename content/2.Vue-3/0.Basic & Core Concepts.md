# Basic & Core Concepts

## `Interpolation`
Interpolation, Vue bileşenlerinde veri gösterimi için kullanılan bir yöntemdir.
Çift süslü parantez ```{{}}``` içinde bir ifade yazarak, bileşen içinde veriyi görüntüleyebilirsiniz. Vue,
bu ifadeyi bileşenin veri kaynağından alır ve gerçek değerle değiştirir. Örneğin:

```
<template>
    <div>
        <p>{{ message }}</p>
    </div>
</template>
<script>

export default {
    data() {
        return {
            message: "Merhaba, Dünya!"
        }
    }
}
</script>
```

## `Data Binding`
Data binding (veri bağlama), Vue framework'ünde bileşenlerde verilerin iki yönlü olarak
senkronize edilmesini sağlayan bir mekanizmadır. Bu, veri değiştiğinde bileşenin görüntüsünün
otomatik olarak güncellenmesini ve kullanıcı tarafından yapılan etkileşimlerin veriyi
güncellemesini sağlar.
Vue'da data binding, şu yöntemlerle gerçekleştirilir:

1. One-Way Data Binding (Tek Yönlü Veri Bağlama):
   - İnterpolasyon (Interpolation): Çift süslü parantez {{ }} içinde bir ifade kullanarak
   bileşen içindeki veriyi görüntüleyebilirsiniz. Bu yöntemle veri, bileşenin veri kaynağından
   alınır ve gerçek değerle değiştirilir. Örneğin: <p>{{ message }}</p>
   - Direktifler (Directives): Vue'nun özel direktifleri kullanarak veriyi HTML elementlerine
   bağlayabilirsiniz.<br />Örneğin: ```<input v-bind:value="message" />```
2. Two-Way Data Binding (İki Yönlü Veri Bağlama):
   - ```v-model``` Direktifi: Vue'nun ```v-model``` direktifi, bir form elemanının değerini bileşenin veri
   kaynağıyla senkronize etmek için kullanılır. Kullanıcı bir değeri değiştirdiğinde, veri
   otomatik olarak güncellenir ve veri değiştiğinde bileşenin görüntüsü otomatik olarak
   güncellenir.<br />Örneğin: ```<input v-model="message" />```<br />

Dikkat edilmesi gereken nokta!
Two way data binding yaparken şunu bilmemiz gerekiyor. Ana componentimiz şu olsun: <br />
```
<template>
<div>
    <MyInput v-model="myValue" />
</div>
</template>
<script>

import MyInput from './MyInput.vue';
    export default {
        components: {
            MyInput
        },
    data() {
        return {
            myValue: ''
        }
    }
}
</script>
```
```MyInput``` componentimiz ise şöyle olsun:
```
<template>
<div>
    <input :value="props.myValue" @input="anotherFn" />
</div>
</template>
<script lang="ts" setup>

import { defineProps } from 'vue';

const props = defineProps({
    myValue: {
        type: String,
        required: true
    }
})
</script>
```
Bu örnekten şunu anlayabiliriz. ```v-model=”myValue”``` ile belirttiğimiz zaman alt componentten bu
değerleri ```value``` ve ```@input``` olarak kullanabiliriz.

## `Binding Attributes`
Vue içerisinde attributeleri bind edebilmek için Vue bize şöyle bir imkan sağlıyor.
```
<a v-bind:href="url">Link</a>
    // method 1
<img :src="imageSrc" alt="Image">
    // method 2
```
```href``` ve ```src``` attributeleri ```url``` ve ```imageSrc``` değişkenlerine bind edilmiştir.

## `Understanding Methods in Vue`
Vue componenti içinde metotlarımızı yazmak için izleyeceğimiz yollar şunlardır:
```
<script setup lang="ts">

const methodDefault = () => {
    console.log('method default');
};
</script>
<template>
<div>
    <button @click="methodDefault">Tıkla</button>
</div>
</template>
```
Fonksiyonlar ES5 ve ES6 yazım tipi ile yazılır mesela:
```
function methodDefault() {
    console.log("method default");
}
```
Yazımı da doğrudur. Fonksiyonlar aynı zamanda interpolation olarak bind edilebilir
```
<div> {{ methodReturnNumber() }} </div>

```
## `v-html`
Vue string değerlerimizi element içlerinde html formatında yazmamıza imkan sağlar.
```
<template>
    <section v-html="htmlContent"></section>
</template>
<script lang="ts" setup>

const htmlContent = ref<string>("<div><p>Html İçeriğim</p></div>");
</script>
```

## `Event Binding`
Event Binding yaparken ```v-on``` veya ```@``` kullanmalıyız. <br/>
Tanımladığımız metotları eventlerle eşleştirerek çalıştırabiliriz.<br/>
```$event``` objesini örnekteki gibi tutmak istiyorsak ilk parametre olarak göndermeli ve ilk
parametre olarak metotta almalıyız.
```
<script setup lang="ts">

const methodDefault = (event: InputEvent, data: string) => {
    console.log(data, event);
};
</script>

<template>
    <p @click="methodDefault($event, 'Hello')">Tıkla</p>
</template>
```
Extra olarak event tanımlaması içine fonksiyon adı yerine tek satırlık işlemler koyabiliriz.
Örneğin;
```
<template>
    <p @click="numberOne++">Tıkla</p>
</template>

<script setup lang="ts">

const numberOne = ref<number>(0);
</script>
```
## `Event Modifiers`
Event Modifiers, eventler tanımlanırken bazı ön komutlar vermemizi sağlar.
- prevent
  ```
  <form @submit.prevent="submitForm">
    <input v-model="myValue" />
    <button type="submit">Submit</button>
  </form>
  ``` 
.prevent, form submit edilirken preventDefault() fonksiyonunun çalışmasını ve sayfanın
tekrar render edilmemesini sağlar.
- once
    ```
    <p @click.once="clickOnlyOneTime">Click Me!</p>
    ``` 
Bu modifier ise eventin ilk tetiklenmesinden sonra kendini yok eder ve bir daha çalışma
imkanı olmaz yani bu event listener sadece bir kez çalışır.
```.capture``` ```.stop``` ```.self``` modifierları da kullanılmaktadır.

## `Computed`
Bir değere veya veriye bağlı olarak başka bir alanın anlık değişimlerinin yapılması için
dinleme işlemlerini gerçekleştirdiğimiz yere ```computed``` diyoruz. <br/>
Vue ```ref``` ve ```reactive``` haricinde biraz daha özelleştirebileceğimiz ```computed``` fonksiyonunu
sunuyor. ```computed``` fonksiyonu da aynı ```ref``` ve ```reactive``` gibi değişken tanımlamasında
kullanılır. Ek olarak ```computed``` ifadeleri readonly ve writable yaparak özelleştirebiliriz. Bir
örnek inceleyelim.
```
const name = ref<string>("Ahmet");
const surname = ref<string>("Özdemir");

const fullName = computed<string>(()=> `${name.value} ${surname.value}`);
```
Bu örnekte ```computed``` readonly olarak kullanılmış ve fullName adında bir reaktif değişken
oluşturulmuştur. Peki writable ```computed``` ifadeleri nasıl yazılır?

```
const name = ref<string>("Ahmet");
const surname = ref<string>("Özdemir");
const acceptedNames = ref<string[]>("Ali", "Ahmet", "Melisa");

const isAccepted = computed<boolean>({
get: () => acceptedNames.some((name)=> name===name.value),
set: (val: string[]) => {
    acceptedNames = val;
    }
});

console.log(isAccepted.value); // true
isAccepted.value = ["Azra", "Elif", "Samet"];
console.log(isAccepted.value); // false
```
Vue2’den hatırlarsak ```computed``` metotları parametre almadan çalışıyordu fakat Vue3 ile
birlikte set’e parametre gönderebiliyoruz.

## `Watch`

```watch```, reaktif değişkenlerimizi takip etmeye yarayan bir metottur. watch , reaktif
değişkenlerin değişimine verilecek aksiyonu kurmamızı sağlar. Parametre olarak sıralı bir
şekilde eski ve yeni değerleri alabiliriz.

```
const myNumber = ref<number>(0);
const yourNumber = ref<number>(0);
watch(myNumber,(oldValue, newValue)=> {
    console.log(`myNumber değişti! | ${oldValue} -> ${newValue}`);
})

watch([myNumber, yourNumber],([oldMyNumber, newMyNumber], [oldYourNumber, newYourNumber])=> {
    console.log(`myNumber değişti! | ${newMyNumber} -> ${oldMyNumber}`);
    console.log(`myNumber değişti! | ${newYourNumber} -> ${oldYourNumber}`);
})
```
```watch``` options olarak immediate ve deep özellikleri veriyor.
1. immediate → watch fonksiyonu oluşturulur oluşturulmaz çalıştırılır ve izlenen değer
   ```undefined``` döner.
2. deep → Nesneler için derin izleme yapar.
3. flush → ‘pre’ ve ‘post’ değerleri alır. Default olarak ‘pre’dir. Bir reaktif değişken
   değiştiği zaman önce watch fonksiyonu çağırılır ve tabii ki bu reaktif değer DOM
   içerisinde güncellenir. Önce DOM’u manipüle edip sonra ```watch``` fonksiyonunu
   çağırmak istersek ‘post’ yapabiliriz.

## `WatchEffect ve Watch ile farkı`
```watch``` ve ```watchEffect``` arasındaki temel fark, ```watch``` 'ın izlenen değişkenin önceki ve
sonraki değerlerini izleme yeteneğine sahip olmasıdır. Bu, önceki değerle karşılaştırma
yaparak belirli bir eylem gerçekleştirmenize olanak tanır. Öte yandan, ```watchEffect```
sadece izlenen değişkende herhangi bir değişiklik olduğunda çalışır.
Örneğin, bir değişkenin önceki ve sonraki değerlerine ihtiyacınız varsa ```watch```
kullanmalısınız. Ancak, bir değişkenin herhangi bir değişikliğinde işlev çalıştırmak
istiyorsanız, ```watchEffect``` kullanabilirsiniz.
<br/>
```watchEffect``` özelliği için immediate özelliği kullanılmaz çünkü zaten başlangıçta çalışır
fakat flush özelliği ```watch``` ’ta olduğu gibi ```watchEffect``` ’te de vardır.

## `All Style Binding Methods`
Vue componenti içinde style binding için birçok yöntem vardır.
1. String Binding <br/>
```
<div :style="`color: ${textColor}; font-size: ${fontSize}`">
    Hello, Vue!
</div>
```
2. Dynamic Object Binding <br/>
```
<div :style="dynamicStyles">Hello, Vue!</div>
```
```
<script lang="ts" setup>

const dynamicStyles = ref<any>(
    {
        color: "red",
        fontSize: "36px",
    }
);
</script>
```
3. Object Literal Binding <br/>
```
<div :style="{ color: colorData, fontSize: sizeData }">
    Hello, Vue!
</div>
 ```

## `All Class Binding Methods`
Vue componenti içinde class binding için birçok yöntem vardır. 
1. Array Binding <br/>
```
<div :class="[ 'red-text', 'bold' ]">
    Hello, Vue!
</div>
```
2. Object Literal Binding <br/>
```
<div :class="{ 'red-text': isRed, 'bold': isBold }">
    Hello, Vue!
</div>
// isRed ve isBold boolean değerlerdir.
```
3. String Binding <br/>
```
<div :class="classNames">Hello, Vue!</div>
// classNames = 'bg-blue-500 font-bold text-center'
```