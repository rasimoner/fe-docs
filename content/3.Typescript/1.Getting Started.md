# Getting Started
Typescript, Javascript’in bir süper setidir. İlk olarak type safe özelliğinden başlayalım.
```
function add(num1: number, num2: number){
    return num1 + num2;
}
add(5+3);
```
Aynı kodu Javascript içinde type safe prensipleri ile şöyle yazabilirdik.
```
function add(num1, num2){
    if(typeof num1 === "number" && typeof num2 === "number") return num1 + num2;
}
add(5+3);
```
Bu kullanımın performans açısından dezavantajları vardır.
<br />
**Not: Typescriptte type safe tamamen küçük harfler ile yazılır.**
```
const age: number = 6;
```
Bu kullanım yanlış değildir fakat TS type inference özelliğine sahiptir yani atanan tipi
tanır özellikle belirtmeye gerek yoktur.
```
const randomArray = ["çikolata", 4, "muz", 9];
// randomArray: (string | number)[];
```
TS bunu bilir bunu type inference denir.

## Object Types
```
const person : {
    name: string;
    surname: string;
} = {
    name: "Ahmet",
    surname: "Özdemir"
};
```
Objeler içindeki attribute’lerin tipleri ile birlikte tanımlanırlar yukarıda ki örnek gibi.

## Tuple Types
Tuple normal JS içinde olmayan özel dizilerdir. Sabit eleman sayısından oluşan
yapılardır TS bu elemanlara tabii ki tip ataması da yapar.
```
const person : {
    name: string,
    age: number,
    role: [number, string]
} = {
    name: "Ahmet",
    age: 23,
    role: [1, "admin"]
}
```
role attribute’ü sadece 2 eleman alabilir ve bunlar sırasıyla ```number``` ve ```string``` olmak
zorundadır.

## Enums
Tuple iş görür fakat bunun için TS bize daha iyi bir seçenek sunuyor enumlar.
```
enum enumRole {
    ADMIN = 1,
    USER = 2
}
const person : {
    name: string,
    age: number,
    role: enumRole
} = {
    name: "Ahmet",
    age: 23,
    role: enumRole.ADMIN
}
```

## Any Type
any tip ataması TS için oldukça esnek bir tip atamasıdır. Değişkene her türlü değer
ataması yapılabilir. Bu ilk başta avantaj gibi algılansa da aslında büyük bir
dezavantajdır. Çünkü Typescript’in sunduğu bütün avantajları yok eder ve Vanilla JS
deneyimi yaşatır. Büyük projelerde başımıza bela olur.

```
let age : any = 5;
age = "5";
// no error
```

## Union Types

Değişkenlerimize veya parametrelerelerimize tip ataması yaparken bazen birden fazla
tip ataması yapmak isteyebiliriz. Bu durumda union types dediğimiz tip ataması
gerçekleşir.
```
const users = [{id: 0, nickname: "AhmetOzdemir"}, {id:1, nickname: "CeyhunSakal"}];
function findUserbyId(id: string | number) { // id bilgisi string veya number gelebilir
    return users.find((user) => user.id == id)?.nickname;
}
console.log(findUserbyId(0)); // 'AhmetOzdemir'
console.log(findUserbyId("1")); // 'CeyhunSakal'
```

## Literal Types
Bir literal tipi, sadece belirli bir sabit değerle eşleşen değerleri kabul eder. Örneğin, bir
dize literal tipi şu şekilde tanımlanabilir:
```
type Greetings = "Hello" | "Hi" | "Hey";
```
Bu, "Hello", "Hi" veya "Hey" dışındaki başka bir dizeyi kabul etmeyen "Greetings" adlı bir
tür tanımlar.
<br />
**NOT: Literal tipler, bir değerin belirli bir sabit değere sahip olduğunu belirten
türlerdir. Öte yandan, interface'ler, nesnelerin veya sınıfların sahip olabileceği
özelliklerin türünü tanımlamak için kullanılır.**

## Function Returns Type or Void

TS tip güvenliğine oldukça önem veriyor öyle ki fonksiyonlarımızın dönüş tipini bile
ayarlayabiliyoruz �
```
function add(num1: number, num2: number) : number {
    return num1 + num2;
}
// it works!!!
```

TS zaten dönüş tiplerini derlenme aşamasında kestirir ve bilir fakat güvenlik için
özellikle belirtilebilir. Örneğin üstteki fonksiyonda dönüş tipini belirtmesekte TS number
olacağını biliyordu.

## Functions in Parameters

Fonksiyonlarımız parametre içlerinde nasıl tanımlanır görelim.

```
function addNumbers(n1: number, n2: number, fnc: (value: number) => void) {
    const result = n1 + n2;
    fnc(result);
}
addNumbers(3, 5, (value: number)=> {
    console.log(value);
});
```

## Unknown Type

TS için ```unknown``` tip, gelecek olan değişkenin tipinin belli olmadığı durumlarda kullanılır.
```any``` tipine benzer ama aralarında büyük bir ```any``` tipinde type safe yok. ```any``` ile belirtilmiş
bir değişkene her türlü değişken atanabilir ama ```unknown``` ```type safe``` özelliğine sahip
sadece kendisine gelecek olan değişkenin tipini bilmiyor ve ```unknown``` tipine sahip
değişkenler kullanmadan önce tip kontrolü yapılmalı yoksa TS hata verir.
```
function printConsole(value: unknown) {
    if(typeof value === 'string') console.log(value);
}
printConsole("Typescript...");
```

## Never Type

```never``` sadece fonksiyonlara atanır değişkenlere atanmaz. ```never``` tipi, bir fonksiyonun
asla tamamlanmayacağını veya hata fırlatacağını garanti eder. Bu tür fonksiyonlar,
özellikle programın hatalı durumlarda sonlandırılması gerektiği durumlarda oldukça
faydalı olabilir. Aşağıdaki örneklerde ```never``` tipinin kullanımına dair bazı senaryolar
verilmiştir:

- Hata fırlatma: ```never``` tipi, bir fonksiyonun ```throw``` anahtar kelimesiyle bir hata
fırlatacağını belirtmek için kullanılabilir. Bu, programda oluşabilecek hataları
yönetmek ve öngörmek için kullanılabilir. Örneğin, bir API isteği yapıldığında, isteğin
başarısız olması durumunda bir hata fırlatılabilir ve ```never``` tipi kullanılarak bu hata
durumunun programın sonlandırılacağı garanti edilebilir.
- Sonsuz döngüler: ```never``` tipi, bir fonksiyonun sonsuz bir döngüde kaldığını belirtmek
için kullanılabilir. Bu, bir döngü içindeki işlemlerin asla tamamlanmayacağı
durumlarda kullanılabilir. Örneğin, bir sunucu uygulamasında, bir işlem sürekli
olarak belirli bir işleve dayanarak çalışıyorsa, ```never``` tipi kullanılabilir.
- İşlem sonlandırma: ```never``` tipi, bir fonksiyonun programı sonlandıracağını belirtmek
için de kullanılabilir. Örneğin, bir komut satırı uygulamasında, bir komutun yanlış
kullanımı durumunda programın sonlandırılması gerekebilir ve bu durumda ```never```
tipi kullanılabilir.

Genel olarak, never tipi, programın belirli durumlarda güvenli bir şekilde
sonlandırılmasını sağlayan bir araçtır. Bu durumlarda, programın beklenmedik bir
şekilde çökmesi veya çalışmaya devam etmesi önlenir.

## Type Defination vs ‘as’ usage

Tür belirlemesi ve ```as``` kullanımı arasında ufak farklılıklar ve benzerlikler var.
<br />
Benzerlikler şunlardır;
- İki kullanımda türü tip belirlemesi yapar.
Farklılıklar şunlardır;
- Tür belirlemesi daha güvenlidir. Çünkü as kullanımında bir tür ataması yaparız
fakat bunu derleyici izlemez ve farklı bir tür ataması olduğunda bu bize hata olarak
döner.

```
// Tür Belirlemesi
let value1: number = "10"; // Hata: 'string' türü 'number' türüne atfedilemez.
// "as" Operatörü
let value2 = "10" as number; // Hiçbir hata olmadan derlenir, ancak değer 'undefined' olur.
console.log(value1); // Hata olduğu için bu satır çalışmaz.
console.log(value2); // Çıktı: undefined
```
**NOT:** ```as``` kullanımı yerine her zaman tür belirlemesi kullanmak daha güvenlidir, önerilir
artı olarak ifade berraklığı ve kod için daha iyi bir bakım imkanı sunar kodu daha
izlenebilir kılar.