# Classes & Interfaces

OOP için class yapılarını bilmemiz lazım. OOP kısacası günlük hayatımızda ki nesneleri
varlıkları programlamaya uydurmaya çalışır.
<br />

Örneğin bi HBYS için ‘Patient’ class’ı oluşturuyoruz ve bu class name, surname,
birthDate, gender vs. gibi birçok data tutulur. Kısacası günlük hayat verilerini
programlamaya uygulamak üzerine bir yöntemdir.

## Creating a First Class

```
class Person {
    fullname: string;
    constructor(fullname: string) {
        this.fullname = fullname;
    }
    describe() {
        console.log(this.fullname);
    }
}

const person1 = new Person("Ahmet");
// created a class
```

## Public & Private

OOP, programlama da private ve public erişilebilirlik durumu önemlidir. Eğer
değişkenimizin sadece class içinden erişilebilir olmasını istiyorsak private yaparız.
<br />
**Default olarak public’tir. Erişime full açıktır.**
<br />
Örneğin şöyle bir classımız olsun.

```
class Account {
    name: string,
    surname: string,
    birthDate: string,
    private balance: number,
    constructor(name: string, surname: string, birthDate: string) {
        this.name = name;
        this.surname = surname;
        this.birthDate = birthDate;
        this.balance = 0;
    }
    addToBalance(add: number) {
        this.balance += add;
    }
    minusToBalance(minus: number) {
        this.balance -= minus;
    }
}

const person1 = new Account("Ahmet", "Özdemir", "2000-07-05");
```

Bu banka hesabımızın basit bir class yapısı olsun. Bu class’ta ```balance``` (bakiye) eğer
public olursa diğer geliştiriciler tarafından veya bizim tarafımızdan oldukça tehlikeye
açıktır. Değişken direkt olarak değiştirilmesi uygun olmayan bir değişkendir. Onun yerine
```addToBalance()``` ```minusToBalance()``` metodu kullanılabilir.

## Shorthand Initialization

Yukarıda ki classı tanımlarken bazı kısayollara başvurabiliriz.

```
class Account {
    private balance: number,
    constructor(public name: string, public surname: string, public birthDate: string) {
        this.balance = 0;
    }
}
```

## Readonly

```readonly``` ve ```const``` birbirine benzeyen özellikler olsa da, aralarında bazı farklılıklar vardır.
<br />
İlk olarak, ```const``` değişkenleri genellikle bir değere atanırken, ```readonly``` değişkenleri
genellikle bir nesneye veya sınıfa atanır. Yani ```const``` ile bir değişken tanımladığınızda,
bu değişkene sadece bir değer atanabilir ve bu değer daha sonra değiştirilemez.
<br />

```readonly``` değişkenlerinde ise nesne veya sınıfın özelliklerine erişmek için kullanılırlar ve
bu özelliklere atama yapmak mümkündür. Ancak, bir kez atanan ```readonly``` özellikler,
daha sonra değiştirilemez.

## Inheritance

Classlar arasında kalıtım sağlamak için TS ```extends``` keyword’ünü kullanıyor. Bu şekilde
üst sınıfın değişkenleri ve metotları alt sınıfa aktarılır.

```
class Department {
    constructor(public name: string){}
    printDepartmentName() {
        console.log(this.name);
    }
}

class BTDepartment extends Department {
    constructor(name:string, public location: string){
        super(name);
    }
}

const d1 = new Department("Default");
const d2 = new BTDepartment("BT", "Istanbul");

d1.printDepartmentName(); // 'Default'
d2.printDepartmentName(); // 'BT'
```

## Protected

TypeScript'te ```protected``` erişim belirleyicisi, bir sınıfın üyelerinin yalnızca sınıfın kendisi
ve alt sınıflar tarafından erişilebilir olmasını sağlar. Yani, ```protected``` olarak işaretlenmiş
bir sınıf üyesi, sınıfın kendisi veya o sınıfı miras alan alt sınıflar tarafından erişilebilir,
ancak sınıfın dışındaki diğer kodlar tarafından erişilemez.
<br />

Bir sınıf üyesini ```protected``` olarak işaretlemek için, üyenin önüne ```protected``` anahtar
kelimesi eklenir:

```
class Animal {
    protected name: string;
    protected constructor(name: string) {
        this.name = name;
    }
}

class Dog extends Animal {
    constructor(name: string) {
        super(name);
    }
    public bark(): void {
        console.log(`Woof! My name is ${this.name}.`);
    }
}

const dog = new Dog('Fido');
dog.bark(); // "Woof! My name is Fido."
```

## Getter & Setter

TypeScript, ECMAScript 5'ten itibaren JavaScript'e get ve set özelliklerini ekledi. Bu
özellikler, bir sınıfın veya nesnenin özelliklerini tanımlamak ve erişmek için kullanılır.
TypeScript, get ve set özelliklerinin kullanımını basitleştirmek için bir dizi özellik sağlar.

### Getter

Bir getter, bir özelliğe erişmek için kullanılan bir işlevdir. Getter, bir nesnenin özelliklerine
erişirken arka planda belirli bir işlevi çalıştırır. Getter, bir işlev gibi yazılır, ancak bir
özellik gibi çağrılır.
<br />

Örneğin, aşağıdaki örnekte, ```Person``` sınıfının ```fullName``` adlı bir özelliği vardır. Bu özelliğe
erişirken, ```get``` anahtar kelimesi kullanılarak ```fullName``` adlı bir getter işlevi tanımlanmıştır:

```
class Person {
    private _firstName: string;
    private _lastName: string;
    constructor(firstName: string, lastName: string) {
        this._firstName = firstName;
        this._lastName = lastName;
    }
    get fullName(): string {
        return `${this._firstName} ${this._lastName}`;
    }
}

let person = new Person("John", "Doe");
console.log(person.fullName); // "John Doe"
```

Bu örnekte, ```Person``` sınıfının ```fullName``` özelliği, ```_firstName``` ve ```_lastName``` özelliklerinin
birleşiminden oluşan tam adı döndüren bir getter işlevi ile tanımlanmıştır. ```fullName```
özelliği, sınıf dışında çağrılabilecek bir işlev değil, bir özellik gibi kullanılabilecek bir
işlevdir.

### Setter

Bir setter, bir özelliğin değerini ayarlamak için kullanılan bir işlevdir. Setter, bir nesnenin
özelliklerine erişirken arka planda belirli bir işlevi çalıştırır. Setter, bir işlev gibi yazılır,
ancak bir özellik gibi çağrılır.
<br />

Örneğin, aşağıdaki örnekte, ```Person``` sınıfının ```fullName``` adlı bir özelliği vardır. Bu özelliğe
değer atarken, ```set``` anahtar kelimesi kullanılarak ```fullName``` adlı bir setter işlevi
tanımlanmıştır:

```
class Person {
    private _firstName: string;
    private _lastName: string;
    constructor(firstName: string, lastName: string) {
        this._firstName = firstName;
        this._lastName = lastName;
    }
    get fullName(): string {
        return `${this._firstName} ${this._lastName}`;
    }
    set fullName(value: string) {
        const [firstName, lastName] = value.split(" ");
        this._firstName = firstName;
        this._lastName = lastName;
    }
}

let person = new Person("John", "Doe");
console.log(person.fullName); // "John Doe"

person.fullName = "Jane Smith";
console.log(person.fullName); // "Jane Smith"
```

## Static Methods & Properties

TypeScript'te static metotlar ve static özellikler, bir sınıfa ait olan ve doğrudan sınıf adı
ile erişilebilen özelliklerdir. Bu nedenle, bir sınıfın örneği oluşturulmadan kullanılabilirler.

- Static Metotlar: Bir sınıfa ait olan ancak sınıfın bir örneği oluşturulmadan doğrudan
  çağrılabilen metotlardır. Yani, bir nesne örneği oluşturmadan sınıf adıyla doğrudan
  erişilebilirler. Static metotlar, genellikle yardımcı işlevler veya kullanımı kolay hale
  getirmek için kullanılan yöntemlerdir. İşte bir örnek:

```
class MathUtils {
    static addNumbers(a: number, b: number): number {
        return a + b;
    }
}

const result = MathUtils.addNumbers(5, 10);
console.log(result); // 15
```

Yukarıdaki örnekte, "MathUtils" adında bir sınıf tanımladık ve içinde "addNumbers"
adında bir static metot oluşturduk. Bu metot, iki sayıyı toplar. Daha sonra, static metodu
doğrudan sınıf adıyla çağırarak kullanabiliriz.

- Static Özellikler: Bir sınıfın tüm örnekleri tarafından paylaşılan ve sınıfa ait olan
  özelliklerdir. Bu özellikler, sınıfın örneği oluşturulmadan doğrudan sınıf adıyla
  erişilebilirler. İşte bir örnek:

```
class Counter {
    static count = 0;
    static increment() {
        Counter.count++;
    }
    static decrement() {
        Counter.count--;
    }
}

Counter.increment();
Counter.increment();
Counter.decrement();

console.log(Counter.count); // 1
```

Yukarıdaki örnekte, "Counter" adında bir sınıf tanımladık ve içinde "count" adında bir
static özellik oluşturduk. Bu özellik, sınıfın tüm örnekleri tarafından paylaşılır.
"increment" ve "decrement" adında iki static metot oluşturduk, bu metotlar sayacı artırıp
azaltır. Daha sonra, "increment" ve "decrement" metotlarını çağırdık ve "count" özelliğini
konsola yazdırdık.
<br />

Özetle, TypeScript'te static metotlar ve özellikler, sınıfa ait olan ve doğrudan sınıf adı ile
erişilebilen özelliklerdir. Static metotlar genellikle yardımcı işlevler veya genel kullanıma
sahip işlemler için kullanılırken, static özellikler sınıfın tüm örnekleri tarafından paylaşılır
ve genellikle sayac gibi sınıfın durumunu takip eden veriler için kullanılır.

## Abstract Classes

Abstract classlar diğer adıyla soyut sınıflar direkt olarak örnekleri oluşturulamaz ortak
özelliklerin ve metotların tek çatı altında toplanabilmesi için oluşturulan sınıflardır. Tek
başlarına bir anlam ifade etmezler.
<br />

TypeScript'te abstract classlar, normal classlardan farklı olarak, kendilerinden türetilen
sınıflar için bir şablon görevi gören ve doğrudan örneklendirilemeyen sınıflardır. Abstract
classlar, soyut bir yapıda olup, bir veya daha fazla soyut veya somut üye içerebilirler.
Soyut üyeler, somut bir tanımlamaya sahip olmadan, sadece başvuru amaçlı olarak
kullanılır ve sınıfın alt sınıfları tarafından implemente edilirler.

## GERÇEK HAYAT İÇİN ÖRNEK

```
abstract class Food {
    protected name: string;
    protected price: number;
    constructor(name: string, price: number) {
        this.name = name;
        this.price = price;
    }
    public abstract cook(): void;
    public abstract serve(): void;
    public eat(): void {
        console.log(`Eating ${this.name}`);
    }
}

class Pizza extends Food {
    private slices: number;
    constructor(name: string, price: number, slices: number) {
        super(name, price);
        this.slices = slices;
    }
    public cook(): void {
        console.log(`Cooking ${this.name} pizza`);
    }
    public serve(): void {
        console.log(`Serving ${this.name} pizza (${this.slices} slices)`);
    }
}

class Hamburger extends Food {
    private size: string;
    constructor(name: string, price: number, size: string) {
        super(name, price);
        this.size = size;
    }
    public cook(): void {
        console.log(`Cooking ${this.name} hamburger`);
    }
    public serve(): void {
        console.log(`Serving ${this.name} hamburger (size: ${this.size})`);
    }
}

class Salad extends Food {
    private dressing: string;
    constructor(name: string, price: number, dressing: string) {
        super(name, price);
        this.dressing = dressing;
    }
    public cook(): void {
        console.log(`Preparing ${this.name} salad`);
    }
    public serve(): void {
        console.log(`Serving ${this.name} salad (dressing: ${this.dressing})`);
    }
}

// Kullanım örneği
const pizza = new Pizza("Pepperoni", 15, 8);
pizza.cook(); // Cooking Pepperoni pizza
pizza.serve(); // Serving Pepperoni pizza (8 slices)
pizza.eat(); // Eating Pepperoni

const hamburger = new Hamburger("Cheeseburger", 10, "Large");
hamburger.cook(); // Cooking Cheeseburger hamburger
hamburger.serve(); // Serving Cheeseburger hamburger (size: Large)
hamburger.eat(); // Eating Cheeseburger

const salad = new Salad("Greek Salad", 12, "Vinaigrette");
salad.cook(); // Preparing Greek Salad
salad.serve(); // Serving Greek Salad (dressing: Vinaigrette)
salad.eat(); // Eating Greek Salad
```

Bu örnekte, "Food" abstract sınıfı, yiyeceklerin ortak özelliklerini ve davranışlarını
içeriyor. "Pizza", "Hamburger" ve "Salad" sınıfları ise "Food" sınıfından türetilerek özel
özellikleri ve davranışları ekliyor.

## Interface

Interfaceler bir nesnenin yapısı hakkında ki anlaşmalardır. Bu anlaşmalara uyulması
gerekir. Interfaceler nesnelere ve classlara atanabilir.

```
interface LoginRequest {
    username: string;
    password: string;
    securityNumber?: number; // ?: -> bu değerin olması/olmaması muhtemel demektir.
    combinedLoginValues(): void;
}

const user: LoginRequest;

user = {
    username: "ahmetozdemir",
    password: "123456",
    combinedValues() {
        return `${this.username}${this.password}`;
    }
};
```

## Differences between Interface & Type

### Using Interfaces with Classes

Interfaceler nesneler için bir anlaşma olduğu gibi classlar içinde olabilir.

```
interface IPerson {
    name: string;
    birthdate: string;
    gender: "male" | "female";
}

interface IPersonFunctionality {
    eat() : void;
}

class Person implements IPerson, IPersonFunctionality {
    constructor(
        public name: string,
        public birthdate: string,
        public gender: "male" | "female"
    ){}
    eat() {
        console.log("i'm eating...");
    }
}

const person1 = new Person("Ahmet", "2000-01-01", "male");

person1.eat()
```

Göründüğü gibi classlara birden fazla interface atanabilir.

### Readonly Interface Property

TypeScript'te bir "interface" içinde "readonly" özelliği kullanarak salt okunur özelliklere
sahip bir yapı tanımlayabilirsiniz. Salt okunur (readonly) özellikler, değerleri sadece
okunabilir ve değiştirilemez hale getirir. Bu, belirli bir özelliğin yalnızca başlangıçta
atandığı değeri korumasını sağlar.
<br />

Aşağıda bir örnek kullanarak "readonly" özelliğini içeren bir "interface" tanımını göstereceğim:

```
interface Person {
    readonly name: string;
    readonly age: number;
}

const person: Person = {
    name: "John",
    age: 30,
};

console.log(person.name); // Çıktı: "John"
person.name = "Jane"; // Hata: Cannot assign to 'name' because it is a read-only property.
```

Yukarıdaki örnekte, "Person" adında bir "interface" tanımladık. Bu tanımda, "name" ve
"age" özellikleri salt okunur olarak işaretlendi. Daha sonra, "person" adında bir nesne
oluşturduk ve bu nesne "Person" interface'ini uyguladı. "person" nesnesinin "name"
özelliğini okuyabiliriz, ancak "readonly" olduğu için değiştiremeyiz.
<br />
Bu özellik, veri tutan yapıların korunmasını sağlamak ve istemeden yapıların içeriğini
değiştirmeyi önlemek için kullanılabilir. Özellikle, başka bir yerde yanlışlıkla
değiştirilmesini önlemek istediğiniz değerleri tanımlamak için faydalı olabilir.

### Extending Interfaces

Classlarda olduğu gibi kalıtım interfaceler arasında da vardır farklı olarak classlar tek bir
kalıtım yaparken interfaceler birçok yerden kalıtım sağlayabilir.

```
interface IPersonFunctionalty {
  eat() : void;
  sleep() : void;
}
interface Person extends IPersonFunctionality { // extends interface1, interface2 olabilir
  name: string;
}
```
