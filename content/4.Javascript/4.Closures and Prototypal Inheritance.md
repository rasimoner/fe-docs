# Closures and Prototypal Inheritance

## Functions

**Fonksiyonlar birinci sınıf vatandaştır. İleride göreceğimiz fonksiyonel
programlamanın temelidir.**
<br />
typeof ile bir fonksiyonu denetlediğimiz zaman bize tip dönüşümü olarak Function
dönüyor. Fakat öncelikle şunu kabul etmeliyiz. Fonksiyonlar 99% olarak object gibi
davranır.
<br />

Bir fonksiyonu çağırdığımız zaman otomatik olarak 2 parametre alırız.

- arguments
- this
  Fonksiyonlarımızı çağırmanın 2 yolu vardır;

```
function one(){
    return 1;
}

one(); // method 1
one.call() // method 2
```

Fonksiyonlarımız tanımlandığında bazı propertylere sahiptir.

- bind()
- call()
- apply()
- name
- length

```
function test(){
    return 'test';
}

console.log(test.name); // fonksiyon adını döner | output: 'test'
test.call() // fonksiyonu çağırır.
console.log(test.length) // fonksiyonun parametre sayısını döndürür | output: 0
```

Fonksiyonlar hakkında bilinmesi gereken 3 önemli durum:
<br />

1) Fonksiyonları değişkenlere atayabiliriz.

```
const one = oneFunc(){
    return 1;
}
one();
```

2) Fonksiyonları başka fonksiyonlara parametre olarak verebiliriz.

```
one(fnExample){
    fnExample();
}
one(function(){ return 1; });
```

3) Fonksiyonların parametrelerine default değer atayabiliriz.

```
function showNumber(num=0){
    return num;
}
console.log(showNumber()); // output : 0
console.log(showNumber(10)); // output : 10
```

## High Order Functions

3 tip fonksiyondan bahsedebiliriz.

- Parametresiz Fonksiyon
- Parametreli Fonksiyon
- Fonksiyon Parametreli Fonksiyon ( Yüksek Seviyeli Fonksiyon )
  Yüksek Seviyeli Fonksiyonlar’ın doğru kullanımı projelere her zaman yarar sağlar kod kalitesini arttırır.

## Closures

Closure konsepti, Javascript’te oldukça önemli ve iyi anlaşılması gereken bir konudur.
İlk başta zor gelebilir fakat en basit tanımı ile;

::alert{type="info"}
Bir fonksiyon içinde tanımlanmış alt fonksiyonun, üstünde ki
fonksiyonun değişkenlerine olan erişimine closure denir.
::

Unutmamamız gereken 2 kural var.
- Fonksiyonlar Javascript’te ayrıcalıklı, özel objelerdir.
- Lexical Scope, daha program çalışmadan hangi fonksiyonun hangi değişkene erişimi olduğunu bilir.
Örneğimizi inceleyelim;
```
function one(){
  let ones = "one";
  let unnecessary = "unnecessary";
  return function two(){
    let twos = "two";
    return function three(){
      let threes = "three";
      return `${ones} > ${twos} > ${threes}`
    }
  }
}

console.log(one()()()); // output : 'one > two > three'
```
Burada gerçekleşen çalışma prensibini çok iyi anlamamız lazım. Adım adım incelelim;
- Fonksiyonlarımız iç içe yazıldı bu durumda one ve two fonksiyonlarımız yüksek
mertebeli fonksiyonken three fonksiyonumuz sıradan bir fonksiyondur.
- Js kodu yazıldığında lexical scope en son atıfta bulunulacak bütün değişkenleri
hafızada tuttu. (ones, twos ve thress) fakat hiç atıfta bulunulmayan değişkenleri direkt olarak kaldırdı (unnecessary).
- En alt fonksiyondan yukarı fonksiyonlara doğru erişim olduğu için bütün değişkenler
yazdırılabildi.

```
const one = (num1) => (num2) => num1 + num2;
console.log(one(5)(20)); // output : 25
```
Aynı şekilde parametrelerde closure olarak lexical scope ile tutulur.

## Memory Effect
Closure kullanımı harika bir bellek yönetimi sağlar. Hemen bir örnek yapalım.
```
function heavyEvent(index){
  const arr = new Array(10000).fill("Hello!");
  console.log("New array was created!");
  return arr[index];
}

heavyEvent(1000); // output : New array was created!
heavyEvent(2000); // output : New array was created!
heavyEvent(3000); // output : New array was created!
heavyEvent(4000); // output : New array was created!
heavyEvent(5000); // output : New array was created!
```
Closure ile kullanım ise şöyledir;
```
function heavyEvent(){
  const arr = new Array(10000).fill("Hello!");
  console.log("New array was created!");
  return function(index){
    return arr[index];
  };
}
const origin = heavyEvent();

origin(600); // output : New array was created!
origin(1900);
origin(2600);
origin(4900);
```
Gördüğünüz gibi bu şekilde yazınca sadece bir kez array oluşturuluyor. Bu büyük bir
bellek yönetimi sağlar.

## Encapsulation
```
function bomb(){
  let start = 0;
  let passingTime = () => start++;
  let launch = () => {
    start = 0;
    return 'THE BOMB!!!';
  };
  return {
    passingTime,
    launch,
  }
};

const bomba = bomb();
```
Closure Fonksiyon olarak tanımlanan değişkenler return ile döndürülmez ise
kapsülleme yapılmış olur ve dışarıdan erişime kapatılır.

## Prototypal Inheritance
İlk olarak bilinmesi gereken şudur ki JS’de “class” sözcüğü Java gibi dillerde olan class
ile aynı değildir. Tam nesne yönelimli dillerde class kalıtımı vardır JS’de ise prototypal
kalıtım vardır.
```
const leon = {
  name: "Leon",
  roar: true,
  roarFunction: function() {
    if(this.roar){
      return "ROAR!!!"
    }
  return;
  }
}
const cat = {
  name: "Cat",
}

cat.__proto__ = leon;
console.log(cat.roarFunction());
```
Bu şekilde Cat nesnesi Leon nesnesinden kalıtım sağladı.
<br />
```__proto__``` kullanımı JS derleyicisinin performansı açısından kötüdür.
```
for (prop in leon) {
  console.log(cat.hasOwnProperty(prop) + " " + prop);
}

// true ise nesne bu property'ye sahiptir
// false ise nesne bu property'i üst sınıftan alıyordur.
```
```__proto__``` kullanımı kötü demiştik şimdi doğru ve performanslı bir kullanım olan
Object.create’e bakalım.

```
const cat = Object.create(leon);
```
Son olarak “Prototype Nedir?” bunu öğreneceğiz.
```
function Person(a, s, y) {
  this.adi = a;
  this.soyAdi = s;
  this.yas = y;
}

Person.prototype.adiSoyadi = function() { return this.adi + " " + this.soyAdi; };
var mehmet = new Person("Mehmet", "SEZER", 45);
var yusuf = new Person("Yusuf Sefa", "SEZER", 75);

alert(mehmet.adiSoyadi()); // Mehmet SEZER
alert(yusuf.adiSoyadi()); // Yusuf Sefa SEZER
```